name: Scan with Corellium MATRIX

on:
  push:
    branches: [master]
  pull_request:
    branches: [master]
  schedule:
    - cron: "17 * * * *"
  workflow_dispatch:

concurrency:
  group: ${{ github.event_name == 'schedule' && 'scheduled' || 'non-scheduled' }}
  cancel-in-progress: false

env:
  VPN_CONFIG_PATH: /home/runner/my_vpn_config.ovpn
  MATRIX_RUNNER_ARTIFACTS_PATH: /home/runner/matrix_artifacts.zip
  MATRIX_INSTANCE_ID: ${{ github.event_name == 'schedule' && vars.MATRIX_AUTOMATION_INSTANCE
                        || vars.MATRIX_DEVELOPMENT_INSTANCE }}

jobs:
  changes:
    name: Check for file changes
    runs-on: ubuntu-latest
    # permissions:
    #   pull-requests: read
    outputs:
      ci: ${{ steps.filter.outputs.ci }}
      javascript: ${{ steps.filter.outputs.javascript }}
      markdown: ${{ steps.filter.outputs.markdown }}
      matrix: ${{ steps.filter.outputs.matrix }}
      shell: ${{ steps.filter.outputs.shell }}
    steps:
    - uses: actions/checkout@v4
    - uses: dorny/paths-filter@v3
      id: filter
      with:
        filters: data/config/dorny-paths-filter.yaml
        list-files: 'shell'
  corellium-matrixscan:
    name: Scan with MATRIX
    needs: changes
    if: >-
      ${{
        needs.changes.outputs.matrix == 'true' ||
        needs.changes.outputs.shell == 'true'
      }}
    runs-on: ubuntu-latest
    timeout-minutes: 60
    steps:
      - name: Pull the latest code
        uses: actions/checkout@v4
      - name: Install Node
        uses: actions/setup-node@v4
        with:
          cache: 'npm'
          node-version: 22
      - name: Install Corellium CLI
        run: |
          curl --silent https://status.npmjs.org | grep --quiet "All Systems Operational" ||
            echo "The npm registry may be down"
          npm install --global @corellium/corellium-cli
      - name: Log in to Corellium
        run: |
          corellium login \
            --apitoken ${{ secrets.CORELLIUM_API_TOKEN }} \
            --endpoint  ${{ secrets.CORELLIUM_API_ENDPOINT }}
      - name: Start or create instance
        env:
        timeout-minutes: 10
        run: |
          set -eux && source ./src/functions.sh
          if does_instance_exist "${MATRIX_INSTANCE_ID}"; then
            start_instance "${MATRIX_INSTANCE_ID}"
          else
            log_stdout "Creating instance."
            CREATED_MATRIX_INSTANCE_ID="$(create_instance \
              "${{ vars.MATRIX_DEFAULT_HARDWARE_FLAVOR }}" \
              "${{ vars.MATRIX_DEFAULT_FIRMWARE_VERSION }}" \
              "${{ vars.MATRIX_DEFAULT_FIRMWARE_BUILD }}" \
              "${{ vars.MATRIX_DEFAULT_PROJECT }}")"
            log_stdout "Created instance ${CREATED_MATRIX_INSTANCE_ID}."
            log_stdout "Updating MATRIX_INSTANCE_ID environmental variable"
            echo "MATRIX_INSTANCE_ID=${CREATED_MATRIX_INSTANCE_ID}" >> "${GITHUB_ENV}"
            echo 'CREATED_MATRIX_INSTANCE=true' >> "${GITHUB_ENV}"
          fi
      - name: DEBUG test new env vars DELETE THIS BEFORE MERGING
        run: |
          echo "env.MATRIX_INSTANCE_ID=${{ env.MATRIX_INSTANCE_ID }}"
          echo "MATRIX_INSTANCE_ID=${MATRIX_INSTANCE_ID}"
          echo "env.CREATED_MATRIX_INSTANCE=${{ env.CREATED_MATRIX_INSTANCE }}"
          echo "CREATED_MATRIX_INSTANCE=${CREATED_MATRIX_INSTANCE}"
      - name: Install Appium dependencies
        run: |
          set -eu && source ./src/functions.sh
          install_openvpn_dependencies
          install_usbfluxd_and_dependencies
          install_appium_server_and_dependencies
      - name: Unlock instance after boot
        timeout-minutes: 20
        run: |
          set -eu && source ./src/functions.sh
          start_instance "${{ env.MATRIX_INSTANCE_ID }}"
          wait_until_agent_ready "${{ env.MATRIX_INSTANCE_ID }}"
          unlock_instance "${{ env.MATRIX_INSTANCE_ID }}"
      - name: Connect to project VPN
        timeout-minutes: 2
        run: |
          set -eu && source ./src/functions.sh
          connect_to_vpn_for_instance \
            "${{ env.MATRIX_INSTANCE_ID }}" \
            "${{ env.VPN_CONFIG_PATH }}"
      - name: Connect to device over USB
        timeout-minutes: 1
        run: |
          set -eu && source ./src/functions.sh
          run_usbfluxd_and_dependencies
          add_instance_to_usbfluxd "${{ env.MATRIX_INSTANCE_ID }}"
      - name: Verify USB connection and pair
        timeout-minutes: 1
        run: |
          until idevice_id --list; do sleep 0.1; done
          idevicepair pair
      # - name: Mount the device's Developer Disk Image
      #TODO: Uncomment this step after Appium Runner is stable to reduce rate limiting failures
      #   run: pymobiledevice3 mounter auto-mount
      - name: Install Appium runner and check connection
        continue-on-error: true
        env:
          CORELLIUM_API_ENDPOINT: ${{ secrets.CORELLIUM_API_ENDPOINT }}
          CORELLIUM_API_TOKEN: ${{ secrets.CORELLIUM_API_TOKEN }}
          APPIUM_DEFUALT_PORT: 8100
          APPIUM_RUNNER_LAUNCH_RETRIES: 5
          APPIUM_RUNNER_CURL_RETRIES: 60
        timeout-minutes: 10
        run: |
          set -eu && source ./src/functions.sh
          install_appium_runner_ios "${{ env.MATRIX_INSTANCE_ID }}"
          matrix_instance_services_ip="$(get_instance_services_ip "${{ env.MATRIX_INSTANCE_ID }}")"
          readonly APPIUM_TEST_URL="http://${matrix_instance_services_ip}:${APPIUM_DEFUALT_PORT}/status"
          appium_runner_success='false'
          for launch_attempt in $(seq 1 "${APPIUM_RUNNER_LAUNCH_RETRIES}"); do
            if ! launch_appium_runner_ios "${{ env.MATRIX_INSTANCE_ID }}"; then
              echo "Failed to launch app during attempt ${launch_attempt}"
              continue
            fi
            for curl_attempt in $(seq 1 "${APPIUM_RUNNER_CURL_RETRIES}"); do
              if curl --silent "${APPIUM_TEST_URL}" 2>/dev/null; then
                appium_runner_success='true'
                printf 'Appium runner comms succeeded on launch %s and curl attempt %s' \
                  "${launch_attempt}" \
                  "${curl_attempt}"
                break 2
              fi
              sleep 0.1
            done
          done
          if [ "${appium_runner_success}" != 'true' ]; then
            echo 'FAILED TO ESTABLISH APPIUM COMMS' >&2
            exit 1
          fi
      - name: Install Corellium Cafe from URL
        env:
          CORELLIUM_API_ENDPOINT: ${{ secrets.CORELLIUM_API_ENDPOINT }}
          CORELLIUM_API_TOKEN: ${{ secrets.CORELLIUM_API_TOKEN }}
        run: |
          set -eu && source ./src/functions.sh
          install_corellium_cafe_ios "${{ env.MATRIX_INSTANCE_ID }}"
      - name: Run Corellium Cafe MATRIX assessment
        timeout-minutes: 40
        env:
          CORELLIUM_API_ENDPOINT: ${{ secrets.CORELLIUM_API_ENDPOINT }}
          CORELLIUM_API_TOKEN: ${{ secrets.CORELLIUM_API_TOKEN }}
          MAX_MATRIX_RUN_RETRIES: 2
        run: |
          set -eu && source ./src/functions.sh
          for ((failures=0; failures<=MAX_MATRIX_RUN_RETRIES; failures++)); do
            if run_matrix_cafe_checks "${{ env.MATRIX_INSTANCE_ID }}"; then
              break
            elif [ "${failures}" -lt "${MAX_MATRIX_RUN_RETRIES}" ]; then
              echo "[!] Warning - MATRIX failed on run $((failures + 1))"
            else
              echo "[!] Error - MATRIX failed the max $((failures + 1)) times" >&2
              exit 1
            fi
          done
      - name: Download MATRIX runtime artifacts from VM
        env:
          CORELLIUM_API_ENDPOINT: ${{ secrets.CORELLIUM_API_ENDPOINT }}
          CORELLIUM_API_TOKEN: ${{ secrets.CORELLIUM_API_TOKEN }}
          MATRIX_INSTANCE_ARTIFACTS_PATH: /tmp/matrix_artifacts.zip
        run: |
          set -eu && source ./src/functions.sh
          npm install @corellium/corellium-api
          node ./src/zip_matrix_artifacts.js
          download_file_to_local_path \
            "${{ env.MATRIX_INSTANCE_ID }}" \
            "${MATRIX_INSTANCE_ARTIFACTS_PATH}" \
            "${MATRIX_RUNNER_ARTIFACTS_PATH}"
          ls -la "${MATRIX_RUNNER_ARTIFACTS_PATH}"
          sha256sum "${MATRIX_RUNNER_ARTIFACTS_PATH}"
      - name: Upload MATRIX runtime artifacts
        uses: actions/upload-artifact@v4
        with:
          name: matrix-runtime-artifacts
          path: ${{ env.MATRIX_RUNNER_ARTIFACTS_PATH }}
          compression-level: 9
          if-no-files-found: error
      - name: Upload MATRIX report artifacts
        uses: actions/upload-artifact@v4
        with:
          name: matrix-reports
          path: |
            matrix_report_*.html
            matrix_report_*.json
          compression-level: 9
          if-no-files-found: error
      - name: Stop or delete instance
        if: always()
        timeout-minutes: 2
        env:
          CORELLIUM_API_ENDPOINT: ${{ secrets.CORELLIUM_API_ENDPOINT }}
          CORELLIUM_API_TOKEN: ${{ secrets.CORELLIUM_API_TOKEN }}
        run: |
          set -eu && source ./src/functions.sh
          if [ "${CREATED_MATRIX_INSTANCE:-}" = 'true' ]; then
            echo "DEBUG - FIRST CONDITION MET"
            delete_instance "${NEW_MATRIX_INSTANCE_ID}"
          else
            echo "DEBUG - SECOND CONDITION MET"
            soft_stop_instance "${{ env.MATRIX_INSTANCE_ID }}"
          fi
      - name: Clean up Corellium auth and processes
        if: always()
        timeout-minutes: 1
        env:
          CORELLIUM_CLI_PROFILE: '/home/runner/.config/.corellium/profile.json'
        run: |
          readonly FILES_TO_DELETE=(
            "${{ env.CORELLIUM_CLI_PROFILE }}"
            "${{ env.VPN_CONFIG_PATH }}"
          )
          readonly PROCS_TO_KILL=(
            openvpn
            avahi-daemon
            usbfluxd
          )
          for FILE_PATH in "${FILES_TO_DELETE[@]}"; do
            if [ -f "${FILE_PATH}" ]; then
              echo "[+] Deleting ${FILE_PATH}"
              rm -f "${{ env.CORELLIUM_CLI_PROFILE }}"
            fi
          done
          for PROCESS in "${PROCS_TO_KILL[@]}"; do
            if pgrep "${PROCESS}" > /dev/null 2>&1; then
              echo "[+] Killing ${PROCESS}"
              sudo killall "${PROCESS}"
            fi
          done
